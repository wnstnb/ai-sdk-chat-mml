---
description:
globs:
alwaysApply: false
---
\n\n- **All file uploads MUST undergo server-side validation and security checks.**\n    - This is critical for preventing uploads of malicious files, oversized files, or incorrect file types.\n\n- **Pre-Signed URL Generation Checks (Client-Provided Information):**\n    - When generating signed URLs for client-side uploads (e.g., to Supabase Storage), validate client-provided metadata *before* issuing the URL.\n    - **`fileSize`**: Client MUST provide the intended file size. Validate that it's a positive number and within a defined maximum limit (e.g., 25MB).\n        - Return HTTP 413 (Payload Too Large) if the stated size exceeds the limit.\n    - **`contentType`**: Client MUST provide the intended content type (MIME type).\n        - Validate this against an allowlist of permitted content types for your application.\n        - Return HTTP 415 (Unsupported Media Type) if the stated type is not allowed.\n    - Example: `[app/api/storage/signed-url/upload/route.ts](mdc:app/api/storage/signed-url/upload/route.ts)`\n\n- **Server-Side Processing of Direct Uploads/Buffers:**\n    - **File Size Limit**: Enforce a maximum file size for any buffers received directly by the server.\n        - Example: `PDFProcessingService` checks for 25MB limit.\n    - **Content-Type Verification (Magic Numbers)**: For specific, expected file types (like PDFs), validate the file content using magic numbers, not just relying on extensions or client-provided types.\n        - Example: `PDFProcessingService` checks for `%PDF-` magic number for buffer inputs.\n        - `[app/services/PDFProcessingService.ts](mdc:app/services/PDFProcessingService.ts)`\n\n- **Secure File Naming and Storage:**\n    - **Rename Uploaded Files**: Always rename uploaded files on the server, typically by prepending a UUID or a content hash, to prevent overwriting and path traversal issues related to user-supplied filenames.\n        - Example: `uniqueFileName = \`\${uuidv4()}-\${fileName.replace(/\\s+/g, \'_\')}\`.replace(/[^a-zA-Z0-9_.-]/g, \'\')` in `[app/api/storage/signed-url/upload/route.ts](mdc:app/api/storage/signed-url/upload/route.ts)`.\n    - **Segregate User Files**: Store files in paths that include a user identifier (e.g., `userId/uniqueFileName`) to help with organization and applying per-user access controls.\n\n- **Post-Upload Verification (Essential - Often via Serverless Functions):**\n    - The checks performed *before* a direct client-to-cloud storage upload (via signed URL) are based on client-provided information and are a first line of defense. Robust security requires verification *after* the file lands in storage.\n    - **True Content-Type Verification**: After upload, use server-side tools or libraries (e.g., `file-type` npm package or equivalent) to determine the actual MIME type based on file content (magic numbers/MIME sniffing) and compare against allowed types. Quarantine or delete if mismatched.\n    - **Malware Scanning**: Integrate a malware scanning service (e.g., ClamAV via a serverless function, or a third-party API) to scan all new uploads. Quarantine or delete if malicious content is detected.\n    - **These post-upload steps are typically implemented using cloud functions (e.g., Supabase Functions, AWS Lambda) triggered by new object creation in the storage bucket.**\n\n- **Error Handling:**\n    - Provide clear error messages for validation failures but avoid echoing unsanitized user input.\n
